# This pipeline is based on 1ES build pipeline and it is used to release a new version of an extension on Marketplace.

name: Extension $(ExtensionName) - $(Date:yyyyMMdd)$(Rev:.r)
appendCommitMessageToRunName: false

trigger: none

parameters:
- name: extensionName
  displayName: 'Extension to Build'
  type: string
  default: 'IISWebAppDeploy'
  values:
  - Ansible
  - BitBucket
  - CircleCI
  - ExternalTfs
  - IISWebAppDeploy
  - ServiceNow
  - TeamCity
- name: forceCodeSign
  displayName: 'Force Code Signing (even for non-main branch)'
  type: boolean
  default: false
- name: publishExtension
  displayName: 'Publish Extension to Marketplace'
  type: boolean
  default: false
- name: simulateCodeSigningError
  displayName: 'Simulate code signing error (for testing)'
  type: boolean
  default: false

variables:
# 1ES Security Scanning
- name: CodeQL.Enabled
  value: true
# Publisher
- name: PublisherId
  value: 'ms-vscs-rm'
# ESRP Signing secrets
- group: EPS.ESRPSigningProdAME
# Dynamic
- name: ExtensionName
  value: ${{ parameters.extensionName }}
- name: IsMainBranchBuild
  value: $[eq(variables['Build.SourceBranchName'], 'main')]

resources:
  repositories:
  - repository: 1ESPipelineTemplates
    type: git
    name: 1ESPipelineTemplates/1ESPipelineTemplates
    ref: refs/tags/release

extends:
  template: v1/1ES.Official.PipelineTemplate.yml@1ESPipelineTemplates
  parameters:
    sdl:
      sourceAnalysisPool:
        name: 1ESPtTfsAgentBuildPoolSDL
      spotBugs:
        enabled: false
      credscan:
        enabled: true
      binskim:
        enabled: true
      eslint:
        enabled: true

    pool:
      name: 1ESPtTfsAgentBuildPool1

    customBuildTags:
    - ES365AIMigrationTooling
    - 1ES-AzureExtensions
    - SecureExtensionOnboarding
    - Extension-${{ parameters.extensionName }}

    stages:

    # ======= Build & Package (prepare production and test version of the extension) =======
    - stage: Build_And_Package_For_Production_And_Test
      displayName: 'Build & Package (prepare PROD and test version of the extension)'
      jobs:
      - job: BuildAndPackage
        displayName: 'Build & Package job for preparing PROD and test version of the extension'
        templateContext:
          outputs:
          - output: pipelineArtifact
            displayName: 'Make unsigned PROD build artifacts available'
            targetPath: '$(System.ArtifactsDirectory)/unsigned'
            artifactName: 'vsix-unsigned'
          - output: pipelineArtifact
            displayName: 'Make unsigned test build artifacts available'
            targetPath: '$(System.ArtifactsDirectory)/test-unsigned'
            artifactName: 'vsix-test-unsigned'
        steps:
        - checkout: self
          displayName: 'Checkout repository'
          clean: true
          fetchTags: false

        - task: NodeTool@0
          displayName: 'Use Node.js 20.x'
          inputs:
            versionSpec: '20.x'

        - task: Npm@1
          displayName: 'Install dependencies'
          inputs:
            command: install
            verbose: false

        - task: Npm@1
          displayName: 'Install TFX CLI (needed for publishing on Marketplace)'
          inputs:
            command: custom
            customCommand: 'install -g tfx-cli'

        - task: Npm@1
          displayName: 'Install Gulp CLI'
          inputs:
            command: custom
            customCommand: 'install -g gulp-cli'

        - task: PowerShell@2
          displayName: 'Build PROD resources'
          inputs:
            targetType: inline
            script: 'gulp build'
            workingDirectory: '$(Build.SourcesDirectory)'

        - task: PowerShell@2
          displayName: 'Package PROD resources'
          inputs:
            targetType: inline
            script: 'gulp package'
            workingDirectory: '$(Build.SourcesDirectory)'

        - task: CopyFiles@2
          displayName: 'Copy PROD .vsix file to directory for unsigned production artifacts'
          inputs:
            SourceFolder: '$(Build.SourcesDirectory)/_package'
            Contents: '${{ parameters.extensionName }}/*.vsix'
            TargetFolder: '$(System.ArtifactsDirectory)/unsigned'
            flattenFolders: true

        - task: PowerShell@2
          displayName: 'Build test resources'
          inputs:
            targetType: inline
            script: 'gulp build --test'
            workingDirectory: '$(Build.SourcesDirectory)'

        - task: PowerShell@2
          displayName: 'Package test resources'
          inputs:
            targetType: inline
            script: 'gulp package'
            workingDirectory: '$(Build.SourcesDirectory)'

        - task: CopyFiles@2
          displayName: 'Copy test .vsix file to directory for unsigned test artifacts'
          inputs:
            SourceFolder: '$(Build.SourcesDirectory)/_package'
            Contents: '${{ parameters.extensionName }}/*.vsix'
            TargetFolder: '$(System.ArtifactsDirectory)/test-unsigned'
            flattenFolders: true

    # ======= Sign .vsix artifacts (for PROD and test version of the extension) =======
    - stage: Sign_Vsix_Artifacts
      displayName: 'Sign .vsix artifacts (for PROD and test version of the extension)'
      dependsOn: Build_And_Package_For_Production_And_Test
      condition: or(eq(variables['IsMainBranchBuild'], 'true'), ${{ eq(parameters.forceCodeSign, 'true') }}, ${{ eq(parameters.simulateCodeSigningError, 'true') }})
      jobs:
      - job: SignVsix
        displayName: 'Sign .vsix artifacts job (for PROD and test version of the extension)'
        templateContext:
          outputs:
          - output: pipelineArtifact
            displayName: 'Make signed PROD artifact available'
            targetPath: '$(System.ArtifactsDirectory)/signed'
            artifactName: 'vsix-signed'
          - output: pipelineArtifact
            displayName: 'Make signed test artifact available'
            targetPath: '$(System.ArtifactsDirectory)/test-signed'
            artifactName: 'vsix-test-signed'
        steps:
        - download: current
          artifact: vsix-unsigned
          displayName: 'Download unsigned PROD .vsix'

        - download: current
          artifact: vsix-test-unsigned
          displayName: 'Download unsigned test .vsix'

        - script: |
            echo "Simulated error in signing artifact stage."
            exit 1
          displayName: 'Simulate CodeSigning error'
          condition: ${{ eq(parameters.simulateCodeSigningError, 'true') }}

        - task: EsrpCodeSigning@5
          displayName: 'Sign PROD artifact using ESRP task'
          inputs:
            ConnectedServiceName: '$(Control.EsrpServiceConnectionName)'
            AppRegistrationClientId: '$(Control.AppRegistrationClientId)'
            AppRegistrationTenantId: '$(Control.AppRegistrationTenantId)'
            AuthAKVName: '$(Control.AuthAKVName)'
            AuthCertName: '$(Control.AuthCertName)'
            AuthSignCertName: '$(Control.AuthSignCertName)'
            FolderPath: '$(Pipeline.Workspace)\vsix-unsigned'
            Pattern: '*.vsix'
            signConfigType: inlineSignParams
            inlineOperation: |-
              [
                {"KeyCode":"CP-500813","OperationCode":"AdoExtensionSign","ToolName":"sign","ToolVersion":"1.0","Parameters":{}},
                {"KeyCode":"CP-500813","OperationCode":"AdoExtensionVerify","ToolName":"sign","ToolVersion":"1.0","Parameters":{}}
              ]
            SessionTimeout: 30

        - task: CopyFiles@2
          displayName: 'Copy signed PROD .vsix file to directory for publishing PROD extension'
          inputs:
            SourceFolder: '$(Pipeline.Workspace)\vsix-unsigned'
            Contents: '*.vsix'
            TargetFolder: '$(System.ArtifactsDirectory)/signed'

        - task: EsrpCodeSigning@5
          displayName: 'Sign test artifact using ESRP task'
          inputs:
            ConnectedServiceName: '$(Control.EsrpServiceConnectionName)'
            AppRegistrationClientId: '$(Control.AppRegistrationClientId)'
            AppRegistrationTenantId: '$(Control.AppRegistrationTenantId)'
            AuthAKVName: '$(Control.AuthAKVName)'
            AuthCertName: '$(Control.AuthCertName)'
            AuthSignCertName: '$(Control.AuthSignCertName)'
            FolderPath: '$(Pipeline.Workspace)\vsix-test-unsigned'
            Pattern: '*.vsix'
            signConfigType: inlineSignParams
            inlineOperation: |-
              [
                {"KeyCode":"CP-500813","OperationCode":"AdoExtensionSign","ToolName":"sign","ToolVersion":"1.0","Parameters":{}},
                {"KeyCode":"CP-500813","OperationCode":"AdoExtensionVerify","ToolName":"sign","ToolVersion":"1.0","Parameters":{}}
              ]
            SessionTimeout: 30

        - task: CopyFiles@2
          displayName: 'Copy signed test .vsix file to directory for publishing test extension'
          inputs:
            SourceFolder: '$(Pipeline.Workspace)\vsix-test-unsigned'
            Contents: '*.vsix'
            TargetFolder: '$(System.ArtifactsDirectory)/test-signed'

    # ======= Approve test extension publishing on Marketplace =======
    - stage: Approve_Test_Extension_Publishing
      displayName: 'Approve test extension publishing on Marketplace (visibility set to private)'
      dependsOn: Sign_Vsix_Artifacts
      condition: and(succeeded(), ${{ eq(parameters.publishExtension, 'true') }})
      jobs:
      - job: ApproveTest
        displayName: 'Manual approval for publishing of the test extension (visibility set to private)'
        pool: server
        steps:
        - task: ManualValidation@0
          timeoutInMinutes: 1440
          inputs:
            notifyUsers: 'razvanmanole@microsoft.com'
            instructions: 'Approve this step to publish the test version of the extension on Marketplace. The visibility of the extension is by default configured to be private.'

    # ======= Publish test extension on Marketplace (visibility set to private) =======
    - stage: Publish_Test_Extension
      displayName: 'Publish test extension on Marketplace (visibility set to private)'
      dependsOn: Approve_Test_Extension_Publishing
      condition: and(succeeded(), ${{ eq(parameters.publishExtension, 'true') }})
      jobs:
      - job: PublishTestExtension
        displayName: 'Publish test extension on Marketplace'
        steps:
        - download: current
          artifact: vsix-test-signed
          displayName: 'Download the signed version of test .vsix'

        - task: NodeTool@0
          displayName: 'Use Node.js 20.x'
          inputs:
            versionSpec: '20.x'

        - task: TfxInstaller@5
          displayName: 'Install TFX'
          inputs:
            version: 'v0.21.1'

        - task: 1ES.PublishAzureDevOpsExtension@1
          displayName: 'Publish test extension'
          inputs:
            connectTo: AzureRM
            connectedServiceNameAzureRM: '1es-extensions-publication-secure-service-connection'
            fileType: vsix
            vsixFile: '$(Pipeline.Workspace)/vsix-test-signed/*.vsix'
            targetPath: '$(Pipeline.Workspace)/vsix-test-signed'
            validateExtension: false
            useV5: true

    # ======= Execute CI tests and verify newly published test extension =======
    - stage: Execute_CI_Tests
      displayName: 'Execute CI tests and verify newly published test extension'
      dependsOn: Publish_Test_Extension
      condition: succeeded()
      variables:
        CI_TESTS_ORG_URL: 'https://dev.azure.com/canarytest'
        CI_TESTS_PROJECT:  'PipelineTasks'

      jobs:
      - job: QueuePipelineRunAndWaitForResult
        displayName: 'Trigger pipeline with CI tests for extension and wait for the result'
        timeoutInMinutes: 120

        steps:
        - pwsh: |
            $ErrorActionPreference = 'Stop'
            $selectedExtensionName = '${{ parameters.extensionName }}'

            switch ($selectedExtensionName) {
              'Ansible' { $pipelineName = 'AzDev-ReleaseManagement-Ansible-CI-Test' }
              default   { throw "Pipeline name can't be determined for '$selectedExtensionName' extension. Update the mapping between the selected extension and pipeline name." }
            }

            Write-Host "Mapping: $selectedExtensionName -> $pipelineName"
            Write-Host "##vso[task.setvariable variable=TARGET_PIPELINE_NAME;]$pipelineName"
          name: DetermineCiTestPipelineName
          displayName: 'Determine the pipeline that will be triggered to verify the selected extension'

        - task: AzureCLI@2
          displayName: 'Trigger selected CI pipeline and wait for the result'
          inputs:
            azureSubscription: 'canarytest-extensions-ci-tests-pipeline-connector'
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              $ErrorActionPreference = 'Stop'

              # Acquire Entra ID token for Azure DevOps resource (499b84ac-1321-427f-aa17-267ca6975798)
              $token = az account get-access-token `
                --resource 499b84ac-1321-427f-aa17-267ca6975798 `
                --query accessToken -o tsv

              if ([string]::IsNullOrWhiteSpace($token)) { 
                throw "Failed to acquire AAD token for Azure DevOps."
              }

              $orgUrl   = "$(CI_TESTS_ORG_URL)".TrimEnd('/')
              $project  = "$(CI_TESTS_PROJECT)"
              $targetPipelineName = "$(TARGET_PIPELINE_NAME)"
              if ([string]::IsNullOrWhiteSpace($targetPipelineName)) {
                throw "TARGET_PIPELINE_NAME is empty. Check the DetermineCiTestPipelineName step."
              }

              $headers = @{
                Authorization = "Bearer $token"
                "Content-Type" = "application/json"
                "Accept" = "application/json"
              }

              # Use pipeline name to get the pipeline ID
              $allPipelinesUrl   = "$orgUrl/$project/_apis/pipelines?api-version=7.1"
              Write-Host "Trying to get pipeline ID by sending GET request to: $allPipelinesUrl"
              $allPipelines = Invoke-RestMethod -Method GET -Uri $allPipelinesUrl -Headers $headers
              $pipelineId = ($allPipelines.value | Where-Object { $_.name -eq $targetPipelineName } | Select-Object -First 1).id
              if (-not $pipelineId) { 
                throw "Pipeline '$targetPipelineName' not found in project '$project'."
              }
              Write-Host "Resolved pipelineId: $pipelineId"

              # Queue the pipeline run
              $runPipelineBody = @{
                resources = @{
                  repositories = @{
                    self = @{ refName = "refs/heads/main" }
                  }
                }
              } | ConvertTo-Json -Depth 4

              $runPipelineUrl = "$orgUrl/$project/_apis/pipelines/$pipelineId/runs?api-version=7.1"
              Write-Host "Trying to queue pipeline run by issuing POST request to: $runPipelineUrl"
              $runPipelineResponse = Invoke-RestMethod -Method POST -Uri $runPipelineUrl -Headers $headers -Body $runPipelineBody

              $runPipelineId = $runPipelineResponse.id
              if (-not $runPipelineId) {
                throw "Queue failed or returned unexpected payload: $($runPipelineResponse | ConvertTo-Json -Depth 10)"
              }
              Write-Host "Queued external pipeline execution with run ID: $runPipelineId"

              # Poll for completion
              $statusUrl = "$orgUrl/$project/_apis/pipelines/$pipelineId/runs/$runPipelineId?api-version=7.1"
              $deadline  = [DateTimeOffset]::UtcNow.AddHours(2)

              do {
                Start-Sleep -Seconds 30
                $status  = Invoke-RestMethod -Method GET -Uri $statusUrl -Headers $headers
                $state   = $status.state
                $result  = $status.result
                Write-Host "Timestamp=$(Get-Date -AsUTC) State=$state Result=$result"
                if ([DateTimeOffset]::UtcNow -gt $deadline) { 
                  throw "Timed out waiting for external pipeline execution with run ID: $runPipelineId."
                }
              } while ($state -ne 'completed')

              if ($result -ne 'succeeded') {
                throw "External pipeline execution with run ID: $runPipelineId is completed with the result: $result"
              }

              Write-Host "External pipeline execution with run ID: $runPipelineId succeeded."

    # ======= Approve PROD extension publishing on Marketplace =======
    - stage: Approve_Prod_Extension_Publishing
      displayName: 'Approve PROD extension publishing on Marketplace'
      dependsOn: Execute_CI_Tests
      condition: and(succeeded(), ${{ eq(parameters.publishExtension, 'true') }})
      jobs:
      - job: ApproveProd
        displayName: 'Manual approval for publishing of the PROD extension'
        pool: server
        steps:
        - task: ManualValidation@0
          timeoutInMinutes: 1440
          inputs:
            notifyUsers: 'razvanmanole@microsoft.com'
            instructions: 'Approve this step to publish the PROD version of the extension on Marketplace. Be careful and ensure that new version is properly tested because after approval changes will be available to all users of the extension.'

    # ======= Publish PROD extension on Marketplace =======
    - stage: Publish_Prod_Extension
      displayName: 'Publish PROD extension on Marketplace'
      dependsOn: Approve_Prod_Extension_Publishing
      condition: and(succeeded(), ${{ eq(parameters.publishExtension, 'true') }})
      jobs:
      - job: PublishProdExtension
        displayName: 'Publish PROD extension on Marketplace'
        steps:
        - download: current
          artifact: vsix-signed
          displayName: 'Download the signed version of PROD .vsix'

        - task: NodeTool@0
          displayName: 'Use Node.js 20.x'
          inputs:
            versionSpec: '20.x'

        - task: TfxInstaller@5
          displayName: 'Install TFX'
          inputs:
            version: 'v0.21.1'

        - task: 1ES.PublishAzureDevOpsExtension@1
          displayName: 'Publish PROD extension'
          inputs:
            connectTo: AzureRM
            connectedServiceNameAzureRM: '1es-extensions-publication-secure-service-connection'
            fileType: vsix
            vsixFile: '$(Pipeline.Workspace)/vsix-signed/*.vsix'
            targetPath: '$(Pipeline.Workspace)/vsix-signed'
            validateExtension: false
            useV5: true
