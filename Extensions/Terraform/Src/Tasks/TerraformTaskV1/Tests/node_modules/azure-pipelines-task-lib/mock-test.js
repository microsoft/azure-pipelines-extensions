"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var cp = require("child_process");
var fs = require("fs");
var os = require("os");
var cmdm = require("./taskcommand");
var shelljs = require("shelljs");
var COMMAND_TAG = '[command]';
var COMMAND_LENGTH = COMMAND_TAG.length;
var MockTestRunner = /** @class */ (function () {
    function MockTestRunner(testPath) {
        this._testPath = testPath;
    }
    Object.defineProperty(MockTestRunner.prototype, "failed", {
        get: function () {
            return !this.succeeded;
        },
        enumerable: true,
        configurable: true
    });
    MockTestRunner.prototype.ran = function (cmdline) {
        return this.cmdlines.hasOwnProperty(cmdline.trim());
    };
    MockTestRunner.prototype.createdErrorIssue = function (message) {
        return this.errorIssues.indexOf(message.trim()) >= 0;
    };
    MockTestRunner.prototype.createdWarningIssue = function (message) {
        return this.warningIssues.indexOf(message.trim()) >= 0;
    };
    MockTestRunner.prototype.stdOutContained = function (message) {
        return this.stdout && this.stdout.indexOf(message) > 0;
    };
    MockTestRunner.prototype.stdErrContained = function (message) {
        return this.stderr && this.stderr.indexOf(message) > 0;
    };
    MockTestRunner.prototype.run = function () {
        var _this = this;
        this.cmdlines = {};
        this.invokedToolCount = 0;
        this.succeeded = true;
        this.errorIssues = [];
        this.warningIssues = [];
        // we use node in the path.
        // if you want to test with a specific node, ensure it's in the path
        var nodePath = shelljs.which('node');
        if (!nodePath) {
            console.error('Could not find node in path');
            return;
        }
        var spawn = cp.spawnSync(nodePath, [this._testPath]);
        if (spawn.error) {
            console.error('Running test failed');
            console.error(spawn.error.message);
            return;
        }
        this.stdout = spawn.stdout.toString();
        this.stderr = spawn.stderr.toString();
        if (process.env['TASK_TEST_TRACE']) {
            console.log('');
        }
        var lines = this.stdout.replace(/\r\n/g, '\n').split('\n');
        var traceFile = this._testPath + '.log';
        lines.forEach(function (line) {
            var ci = line.indexOf('##vso[');
            var cmd;
            var cmi = line.indexOf(COMMAND_TAG);
            if (ci >= 0) {
                cmd = cmdm.commandFromString(line.substring(ci));
                if (cmd.command === 'task.complete' && cmd.properties['result'] === 'Failed') {
                    _this.succeeded = false;
                }
                if (cmd.command === 'task.issue' && cmd.properties['type'] === 'error') {
                    _this.errorIssues.push(cmd.message.trim());
                }
                if (cmd.command === 'task.issue' && cmd.properties['type'] === 'warning') {
                    _this.warningIssues.push(cmd.message.trim());
                }
            }
            else if (cmi == 0 && line.length > COMMAND_LENGTH) {
                var cmdline = line.substr(COMMAND_LENGTH).trim();
                _this.cmdlines[cmdline] = true;
                _this.invokedToolCount++;
            }
            if (process.env['TASK_TEST_TRACE']) {
                fs.appendFileSync(traceFile, line + os.EOL);
                if (line && !cmd) {
                    console.log(line);
                }
                // don't print task.debug commands to console - too noisy.
                // otherwise omit command details - can interfere during CI.
                else if (cmd && cmd.command != 'task.debug') {
                    console.log(cmd.command + " details omitted");
                }
            }
        });
        if (this.stderr && process.env['TASK_TEST_TRACE']) {
            console.log('STDERR: ' + this.stderr);
            fs.appendFileSync(traceFile, 'STDERR: ' + this.stderr + os.EOL);
        }
        if (process.env['TASK_TEST_TRACE']) {
            console.log('TRACE FILE: ' + traceFile);
        }
    };
    return MockTestRunner;
}());
exports.MockTestRunner = MockTestRunner;
