import Q = require('q');
import events = require('events');
import stream = require('stream');
/**
 * Interface for exec options
 */
export interface IExecOptions extends IExecSyncOptions {
    /** optional.  whether to fail if output to stderr.  defaults to false */
    failOnStdErr: boolean;
    /** optional.  defaults to failing on non zero.  ignore will not fail leaving it up to the caller */
    ignoreReturnCode: boolean;
}
/**
 * Interface for execSync options
 */
export interface IExecSyncOptions {
    /** optional working directory.  defaults to current */
    cwd: string;
    /** optional envvar dictionary.  defaults to current process's env */
    env: {
        [key: string]: string;
    };
    /** optional.  defaults to false */
    silent: boolean;
    outStream: stream.Writable;
    errStream: stream.Writable;
    /** optional.  foo.whether to skip quoting/escaping arguments if needed.  defaults to false. */
    windowsVerbatimArguments: boolean;
}
/**
 * Interface for exec results returned from synchronous exec functions
 */
export interface IExecSyncResult {
    /** standard output */
    stdout: string;
    /** error output */
    stderr: string;
    /** return code */
    code: number;
    /** Error on failure */
    error: Error;
}
export declare class ToolRunner extends events.EventEmitter {
    constructor(toolPath: any);
    private toolPath;
    private args;
    private pipeOutputToTool;
    private pipeOutputToFile;
    private _debug;
    private _argStringToArray;
    private _getCommandString;
    private _processLineBuffer;
    private _getSpawnFileName;
    private _getSpawnArgs;
    private _isCmdFile;
    private _windowsQuoteCmdArg;
    private _uv_quote_cmd_arg;
    private _cloneExecOptions;
    private _getSpawnOptions;
    private _getSpawnSyncOptions;
    private execWithPiping;
    /**
     * Add argument
     * Append an argument or an array of arguments
     * returns ToolRunner for chaining
     *
     * @param     val        string cmdline or array of strings
     * @returns   ToolRunner
     */
    arg(val: string | string[]): ToolRunner;
    /**
     * Parses an argument line into one or more arguments
     * e.g. .line('"arg one" two -z') is equivalent to .arg(['arg one', 'two', '-z'])
     * returns ToolRunner for chaining
     *
     * @param     val        string argument line
     * @returns   ToolRunner
     */
    line(val: string): ToolRunner;
    /**
     * Add argument(s) if a condition is met
     * Wraps arg().  See arg for details
     * returns ToolRunner for chaining
     *
     * @param     condition     boolean condition
     * @param     val     string cmdline or array of strings
     * @returns   ToolRunner
     */
    argIf(condition: any, val: any): this;
    /**
     * Pipe output of exec() to another tool
     * @param tool
     * @param file  optional filename to additionally stream the output to.
     * @returns {ToolRunner}
     */
    pipeExecOutputToTool(tool: ToolRunner, file?: string): ToolRunner;
    /**
     * Exec a tool.
     * Output will be streamed to the live console.
     * Returns promise with return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See IExecOptions
     * @returns   number
     */
    exec(options?: IExecOptions): Q.Promise<number>;
    /**
     * Exec a tool synchronously.
     * Output will be *not* be streamed to the live console.  It will be returned after execution is complete.
     * Appropriate for short running tools
     * Returns IExecSyncResult with output and return code
     *
     * @param     tool     path to tool to exec
     * @param     options  optional exec options.  See IExecSyncOptions
     * @returns   IExecSyncResult
     */
    execSync(options?: IExecSyncOptions): IExecSyncResult;
}
